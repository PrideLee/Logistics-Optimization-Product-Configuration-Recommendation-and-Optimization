To Xin：
1. 用户对模块需求就是算法的输入，也可以理解为约束和前提条件，即推荐的方案必须满足模块1的需求；
2. 这个可能我没有说清楚，其具体与哪个有关是由该模块的first order dependency确定的，first order dependency就是和该模块最相关的模块，也就是和该模块一起出现次数最多的模块（可由统计得到），当然找first order dependency也是为了近似计算更精确。另外first order dependency在图论中也有很多运用，其是衡量两节点间的相似性（即边上权值），二阶相似性就是衡量两节点集合的相似性；
3. 为什么能去掉呢，主要就是这个与最终目的无关，我们本质上是要给出configuration，而该项中没有C，因此我们可以认为该项不影响最后的结果，什么意思呢，就是它可以是任意值，我们可以把他看成是定值，无论你的配置方案是什么，它的值都不变，它不影响最后结果。其也是由历史数据确定的

To Kang：
1. 我马上把相关的资料push到网上
2. 这里的数据主要就是和生产配置相关的数据，可以是BOM数据做BOM优化，可以是供应链数据做供应链数据，可以是用户的购买信息、历史行为数据做推荐等；
3. 就是因为现在是“产品系列”，即定制化和模块化设计导致很多产品模块可以替换，然后就有了大量的优化工作，比如说产品设计时配置最优，以及研究供应链时products variety 和 storage cost以及供货周期风险之间存在trade off，然后就有了优化；
4. 这篇文章并没有考虑什么改型、生产成本之类的，当然在实际的推荐应用中肯定是混合推荐的策略，肯定是要考虑多方面因素的，你的recommendation list 可以是“求并”可以是“求交”，可以是加权，可以是投票，等等方案很多；

To Juan:
1. 我的理解是它们两者的目的不同，product definiton是对产品的定义，这个过程主要是要把用户的需求转化为产品设计的功的需求，主要是因为用户需求模糊多样。这个阶段可能还停留在产品的概念设计上，还没有具体产品设计的事。而推荐系统要解决的是将用户的POI或需求对应到具体的某一些产品上，推荐的阶段没有定义产品只是选产品。这两者有类似也有不同，相同的是都是要了解用户需求，不同的是一个侧重在产品的设计，为设计师、产品经理服务，一个是侧重已有在产品的选择过滤，为用户服务。对于将用户需求转换为产品设计这一过程主要有感性工程，移情设计，Kanon模型等，这个过程依赖的数据都是有关用户对产品的期待或要求。而推荐系统主要是基于用户的历史行为数据，例如购买行为，评论，收藏，等等。
2. h就是bootstrap的阈值，bootstrap就是一个重采样的过程，主要是用来生成新的配置方案。如何实现呢，就是首先由标准正态分布随机产生一个【0,1】区间的数，然后利用该随机数与阈值h比较大小，大于阈值我们就从其替代模块组中随机选一个作为新的配置方案的模块，否则就将该原来的配置方案的模块直接赋给新的配置方案。所以就说h越大，配置方案越丰富，因而可以想象满足用户需求的可能性也或许会越大，实验结果也证明随着h的增加推荐的准确性整体上是提高的；


To Xiao:
1. 冷启动问题在推荐系统中一直是一个老大难的问题，尤其是基于CF的方法很难解决。冷启动问题一般的解决思路是融入更多的外部信息来缓解，如新用户注册时的人口统计学特征，还有就是现在的APP一般都会需要获取你的微信信息，其一个目的就是融入里的社交图谱。此外对于新商品就可以使用content-based方法。而这里作者使用probability-based的方法其本来就不是CF的思想，因此其也就不需依赖用户的历史行为数据，所以能在一定程度上缓解冷启动。还有一点就是从任务出发考虑，customer specification本质上就是约束，是计算条件概率的前提，该论文的主要目的就是根据用户的customer specification 推荐完整的configurations，因此本来由任务本质决定其就是MLE问题，所以天然想法就是probability-based的方法，而至于该方法和其他方法有什么差别，第一就是该方法简单可解释性好本质上就是概率的计算最后就是统计（甚至为了简化计算就有independence assumption导出naive bayes），然后就是该方法必须要有指定的输入，就是概率计算的前提也即customer preference/specification。这种方法的缺点当然也很明显，第一就是概率计算时会出现很多为0的情况（这在NLP中就表示为“未登录词”的问题，当然作者用平滑的方法缓解，但在本质没有解决问题），而这在MF中表现为稀疏，因此就会有用两个低维稠密矩阵的乘积拟合高维稀疏矩阵的思想，因此在实际中其使用效果也会大大受限。第二就是该方法需要计算每一种配置情况的概率，这种方法在实际中计算量较大尤其是模块、配置较多时。因此如果真要在实际工程中使用肯定是一个cascade的过程，第一步就是在大范围内筛选出recommendation candidates，第二步才是推荐排序的问题，参考2016年YouTube的推荐论文。
2. BOM推荐和传统推荐的区别，如果把传统推荐认为是e-commercial的推荐然后如果仅将BOM当成一个item而不考虑其内部信息，那么首先在方法可能就会有重叠比如均可使用即有最近邻居的推荐，当然在content-based方法上也会有一些差别，本质主要是BOM是一个器件的集合，其在结构上又有“树状”特点，因此相似度的计算不仅可以考虑内容相似度，还可以考虑结点的层次结构，甚至是tree的拓扑结构相似度。还有就是对于BOM的推荐若数据量有限可能NN的方法就不适用了，它不像2C拥有海量数据能够支持训练。当然如果把BOM视为产品设计的重要内容，那就必须考虑BOM的特有知识和信息，如在推荐时融合BOM优化的东西，考虑零部件间的约束等等，当然这就和“传统”的推荐有了一些差别，或者是在原有的基础上增加了优化的内容，可以考虑更多的条件和约束。就比如在做“吃喝玩乐”的推荐你就肯定要考虑用户的location information等等。






